// src/utils/pick.ts
function pick(arr) {
  return (rng) => {
    const [val, next] = rng.next();
    return [arr[Math.floor(val * arr.length)], next];
  };
}

// src/utils/pad.ts
var PADDING_SYLLABLES = Object.freeze([
  "a",
  "o",
  "u",
  "i",
  "e",
  "ra",
  "ro",
  "ri",
  "re",
  "no",
  "na",
  "ni",
  "ne",
  "li",
  "la",
  "lo",
  "le",
  "ka",
  "ko",
  "ki",
  "ke",
  "ta",
  "to",
  "ti",
  "te",
  "sa",
  "so",
  "si",
  "se",
  "ma",
  "mo",
  "mi",
  "me",
  "da",
  "do",
  "di",
  "de",
  "ba",
  "bo",
  "bi",
  "be",
  "pa",
  "po",
  "pi",
  "pe",
  "xa",
  "xo",
  "xi",
  "xe"
]);
function padToLength(s, min, max, rng) {
  function pad(current, state2) {
    if (current.length >= min) {
      return current.length > max ? current.slice(0, max) : current;
    }
    const [syll, next] = pick(PADDING_SYLLABLES)(state2);
    return pad(current + syll, next);
  }
  return pad(s, rng);
}

// src/utils/phonemes.ts
var ONSETS = Object.freeze([
  "vel",
  "lun",
  "min",
  "ech",
  "cris",
  "amb",
  "mor",
  "ten",
  "zil",
  "fer",
  "sel",
  "nar",
  "vor",
  "tal",
  "rin",
  "cal",
  "fal",
  "gal",
  "hel",
  "jor",
  "bel",
  "cor",
  "del",
  "fen",
  "gar",
  "kar",
  "mel",
  "nel",
  "pel",
  "rel",
  "sol",
  "ven",
  "zen",
  "dor",
  "kir",
  "lex",
  "nex",
  "pix",
  "rex",
  "sil",
  "tol",
  "vex",
  "wil",
  "xen",
  "yan",
  "zor",
  "bron",
  "clar",
  "dren",
  "flen",
  "gran",
  "kron",
  "pren",
  "tren",
  "alk",
  "ark",
  "elk",
  "erk",
  "ilk",
  "irk",
  "olk",
  "ork",
  "ulk",
  "urk",
  "ast",
  "est",
  "ist",
  "ost",
  "ust",
  "ant",
  "ent",
  "int",
  "ont",
  "unt",
  "ald",
  "eld",
  "ild",
  "old",
  "uld",
  "v",
  "l",
  "m",
  "n",
  "r",
  "t",
  "k",
  "f",
  "b",
  "d",
  "g",
  "p",
  "c",
  "s",
  "w",
  "x",
  "y",
  "z",
  "h",
  "j",
  "qu",
  "th",
  "sh",
  "ch",
  "wh",
  "ph"
]);
var NUCLEI = Object.freeze([
  "a",
  "e",
  "i",
  "o",
  "u",
  "ae",
  "ia",
  "ua",
  "eo",
  "ai",
  "ei",
  "oi",
  "au",
  "eu",
  "ou",
  "ie",
  "ue",
  "io",
  "ea",
  "aa",
  "ee",
  "ii",
  "oo",
  "uu"
]);
var CODAS = Object.freeze([
  "",
  "n",
  "r",
  "l",
  "s",
  "m",
  "t",
  "k",
  "p",
  "x",
  "d",
  "g",
  "b",
  "f",
  "v",
  "z"
]);
var TAILS = Object.freeze([
  "ra",
  "ro",
  "ru",
  "la",
  "lo",
  "li",
  "na",
  "no",
  "nu",
  "va",
  "rune",
  "ara",
  "turo",
  "oro",
  "pel",
  "ren",
  "ilo",
  "ava",
  "une",
  "ulo",
  "drel",
  "vion",
  "riel",
  "mar",
  "vra",
  "ka",
  "ko",
  "ki",
  "ta",
  "to",
  "ti",
  "sa",
  "so",
  "si",
  "da",
  "do",
  "di",
  "ba",
  "bo",
  "bi",
  "ma",
  "mo",
  "mi",
  "fa",
  "fo",
  "fi",
  "ga",
  "go",
  "gi",
  "pa",
  "po",
  "pi",
  "xa",
  "xo",
  "xi",
  "za",
  "zo",
  "zi",
  "kra",
  "kro",
  "kri",
  "tra",
  "tro",
  "tri",
  "dra",
  "dro",
  "dri",
  "pra",
  "pro",
  "pri",
  "bra",
  "bro",
  "bri",
  "gra",
  "gro",
  "gri",
  "fla",
  "flo",
  "fli",
  "sla",
  "slo",
  "sli",
  "vra",
  "vro",
  "vri",
  "jan",
  "jen",
  "jon",
  "jun",
  "wan",
  "wen",
  "won",
  "wun",
  "han",
  "hen",
  "hon",
  "hun",
  "can",
  "cen",
  "con",
  "cun",
  "yan",
  "yen",
  "yon",
  "yun",
  "kal",
  "kel",
  "kol",
  "kul",
  "tal",
  "tel",
  "tol",
  "tul",
  "sal",
  "sel",
  "sol",
  "sul",
  "dal",
  "del",
  "dol",
  "dul",
  "nal",
  "nel",
  "nol",
  "nul"
]);

// src/utils/sequence.ts
function sequence(fns, rng) {
  return fns.reduce(
    ([acc, state2], fn) => {
      const [s, next] = fn(state2);
      return [acc + s, next];
    },
    ["", rng]
  );
}

// src/utils/pattern.ts
var PATTERNS = [
  "ON+T",
  "ON+NU+T",
  "CV",
  "CVC",
  "CVT",
  "CVCV",
  "CVCT",
  "CVCVC",
  "VCVCV",
  "CVCVT",
  "CVCTV",
  "CVCVCT",
  "VCVCVC",
  "CVCVCV"
];
var WEIGHTS = [4, 3, 1, 1, 2, 3, 3, 2, 2, 2, 2, 2, 2, 2];
function buildPattern(pattern, rng) {
  switch (pattern) {
    case "ON+T":
      return sequence([pick(ONSETS), pick(TAILS)], rng);
    case "ON+NU+T":
      return sequence([pick(ONSETS), pick(NUCLEI), pick(TAILS)], rng);
    case "CV":
      return sequence([pick(ONSETS), pick(NUCLEI)], rng);
    case "CVC":
      return sequence([pick(ONSETS), pick(NUCLEI), pick(CODAS)], rng);
    case "CVT":
      return sequence([pick(ONSETS), pick(NUCLEI), pick(TAILS)], rng);
    case "CVCV":
      return sequence([pick(ONSETS), pick(NUCLEI), pick(ONSETS), pick(NUCLEI)], rng);
    case "CVCT":
      return sequence([pick(ONSETS), pick(NUCLEI), pick(CODAS), pick(TAILS)], rng);
    case "CVCVC":
      return sequence([pick(ONSETS), pick(NUCLEI), pick(ONSETS), pick(NUCLEI), pick(CODAS)], rng);
    case "VCVCV":
      return sequence([pick(NUCLEI), pick(ONSETS), pick(NUCLEI), pick(ONSETS), pick(NUCLEI)], rng);
    case "CVCVT":
      return sequence([pick(ONSETS), pick(NUCLEI), pick(ONSETS), pick(NUCLEI), pick(TAILS)], rng);
    case "CVCTV":
      return sequence([pick(ONSETS), pick(NUCLEI), pick(CODAS), pick(TAILS), pick(NUCLEI)], rng);
    case "CVCVCT":
      return sequence(
        [pick(ONSETS), pick(NUCLEI), pick(ONSETS), pick(NUCLEI), pick(CODAS), pick(TAILS)],
        rng
      );
    case "VCVCVC":
      return sequence(
        [pick(NUCLEI), pick(ONSETS), pick(NUCLEI), pick(ONSETS), pick(NUCLEI), pick(CODAS)],
        rng
      );
    case "CVCVCV":
      return sequence(
        [pick(ONSETS), pick(NUCLEI), pick(ONSETS), pick(NUCLEI), pick(ONSETS), pick(NUCLEI)],
        rng
      );
  }
}

// src/utils/string.ts
function normalize(s) {
  return s.toLowerCase().normalize("NFKD").replace(/[\u0300-\u036f]/g, "").replace(/[^a-z0-9]/g, "");
}

// src/utils/weighted-pick.ts
function weightedPick(arr, weights, rng) {
  const total = weights.reduce((a, b) => a + b, 0);
  const [r, next] = rng.next();
  const target = r * total;
  function findIndex(index, accumulated) {
    if (index >= arr.length) return arr.length - 1;
    const newAccumulated = accumulated + weights[index];
    return newAccumulated >= target ? index : findIndex(index + 1, newAccumulated);
  }
  return [arr[findIndex(0, 0)], next];
}

// src/utils/generator.ts
function generateName(rng, cfg) {
  const [pattern, rng1] = weightedPick(PATTERNS, WEIGHTS, rng);
  const [base, rng2] = buildPattern(pattern, rng1);
  const baseWord = padToLength(normalize(base), cfg.minLength, cfg.maxLength, rng2);
  return [baseWord, rng2];
}

// src/utils/hash.ts
function hashSeed(input) {
  function hash(h, index) {
    if (index >= input.length) {
      return h >>> 0;
    }
    const newHash = Math.imul(h ^ input.charCodeAt(index), 16777619);
    return hash(newHash, index + 1);
  }
  return hash(2166136261, 0);
}

// src/utils/rng.ts
function createRng(seed) {
  function next() {
    const t = seed + 1831565813 >>> 0;
    const x = Math.imul(t ^ t >>> 15, 1 | t);
    const y = (x ^ x >>> 7 ^ x >>> 14) >>> 0;
    const value = y / 4294967296;
    return [value, createRng(t)];
  }
  return { next };
}

// src/sonare.ts
var state = { counter: 0, lastTime: 0 };
function sonare(options = {}) {
  const { minLength = 6, maxLength = 10 } = options;
  const now = Date.now();
  if (now === state.lastTime) {
    state.counter += 1;
  } else {
    state.lastTime = now;
    state.counter = 0;
  }
  const seed = `${now}-${state.counter}-${Math.random()}`;
  const rng0 = createRng(hashSeed(seed));
  const [word] = generateName(rng0, { minLength, maxLength });
  return word;
}
export {
  sonare
};
